package com.cafecostes.cafe.DB;


import com.cafecostes.cafe.AES256.AES256Cipher;
import com.cafecostes.cafe.domain.OrderList;
import com.cafecostes.cafe.email.EmailServiceImpl;
import com.cafecostes.cafe.kakao.KakaoPay;
import com.cafecostes.cafe.kakao.KakaoPayReadyVO;
import com.cafecostes.cafe.repository.*;
import com.cafecostes.cafe.service.PushNotificationService;
import com.cafecostes.cafe.service.PushPeriodicNotifications;
import com.cafecostes.cafe.service.UsersService;
import lombok.Data;
import lombok.Setter;
import lombok.extern.java.Log;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.CompletableFuture;

@Log
@Controller
@Data
@RequestMapping("flutter")
@RestController
// 플루터에서 들어오는 요청을 처리해주는 컨트롤러
public class FlutterController {

    @Autowired // This means to get the bean called usersRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UsersRepository usersRepository;
    private UsersService usersService;

    @Autowired
    private MenuRepository menuRepository;

    @Autowired
    private OrderListRepository orderListRepository;

    @Autowired
    private CafePostsRepository cafePostsRepository;

    @Autowired
    private ShoppingRepository shoppingRepository;

    @Autowired
    private EmailAuthRepository emailAuthRepository;

    @Autowired
    private SignupEmailAuthRepository signupEmailAuthRepository;

    @Autowired
    JavaMailSender javaMailSender;

    @Autowired
    private WithDrawReasonRepository withDrawReasonRepository;

    @Autowired
    private KakaoPayPaymentRepository kakaoPayPaymentRepository;

    @Autowired
    private CouponRepository couponRepository;

    @Autowired
    private ServerStatusRepository serverStatusRepository;

    @Autowired
    PushNotificationService pushNotificationService;

    @Autowired
    PushNotificationService pushNotificationService2;

    @PostMapping(value = "hello", produces = "application/json")
    public @ResponseBody
    String hello(@RequestParam String userId,
                 @RequestParam String title,
                 @RequestParam String body) {
        log.info(userId + title + body);
        log.info("hello");
        return "hello";
    }

    @RequestMapping(value = "login", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    Users login(
            @RequestBody Login login) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException {

        // 암호화하여 처리
        login.setId(AES256Cipher.AES_Encode(login.getId()));
        login.setPassword(AES256Cipher.AES_Encode(login.getPassword()));

        log.info(login.getId() + login.getPassword());
        log.info("login 접속");
        if (usersRepository.findByUserLoginIdAndUserLoginPassword(login.getId(), login.getPassword()) != null) {
            log.info("flutter 쪽 아이디 있음");
            //return "true";
            Users users = usersRepository.findByUserLoginIdAndUserLoginPassword(login.getId(), login.getPassword());
            log.info("파이어베이스 토큰값 " + login.getFirebaseToken());
            users.setFirebaseToken(login.getFirebaseToken());
            usersRepository.save(users);

            if (shoppingRepository.findByUserName(users.getUserName()) == null) {// 기존의 장바구니 정보를 받아옴 + 추가되는 주문들 넣어줌
                log.info("비어있음");
                Shopping shopping = new Shopping();
                shopping.setUserName(users.getUserName());
                shopping.setList("");
                shopping.setNum("0");
                shopping.setSum_cost("0");

                shoppingRepository.save(shopping);
            }

            // 뿌려줄때는 다시 디코드해서
            users.setUserLoginId(AES256Cipher.AES_Decode(users.getUserLoginId()));
            users.setUserLoginPassword(AES256Cipher.AES_Decode(users.getUserLoginPassword()));
            return users;
        }
        return null;
    }

    //getCoupon
    @RequestMapping(value = "getCoupon", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    String[] getCoupon( @RequestBody Login login){
        log.info("현재 들어온 유저 네임"+ login.getId());
        // 유저 네임으로 들어오는거임
        Iterable<Coupon> coupon;
        try{
            coupon = couponRepository.findAllByUserName(login.getId());
        } catch (Exception e) {
            log.info("error");
            coupon = null;
        }
        if(coupon != null){
            //coupon = couponRepository.findAllByUserName(login.getId());

            Iterator<Coupon> co = coupon.iterator();
            Iterator<Coupon> co2 = coupon.iterator();

            // 유저가 갖고 있는 쿠폰에 대한 길이를 구하는 코드
            int i = 0;
            while (co.hasNext()){
                Coupon coupon2 = co.next();
                if(coupon2.isStatus()){
                    i++;
                }

            }

            int j = 0;
            String coupon_array[] = new String[i];
            while (co2.hasNext()){
                Coupon coupon1 = co2.next();
                if(coupon1.isStatus()){
                    coupon_array[j] =  "쿠폰 번호 : " + coupon1.getId()+ "  쿠폰 이름 : " + coupon1.getCouponName();
                    j++;
                }

            }

            return coupon_array;
        }
        return null;
    }

    // 쿠폰 사용하는 메소드
    @RequestMapping(value = "usingCoupon", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    String usingCoupon( @RequestBody Login login) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException, ParseException {
        // 쿠폰 사용하는것도 중요한거니까 우선 로그인 되는지 확인하고 로그인 된 다음에는
        Users users = usersRepository.findByUserLoginIdAndUserLoginPassword( AES256Cipher.AES_Encode( login.getId() ), AES256Cipher.AES_Encode( login.getPassword() ) );
        // 유저 로그인이 문제가 없다면 널값이 아니므로
        if(users != null){
            log.info("지금 쿠폰 쓴 유저 네임"+ login.getId());
            // 이 파이어베이스 토큰값에는 쿠폰 Id 값이 있음...
            int iInt = Integer.parseInt(login.getFirebaseToken());
            Integer iInteger = new Integer(iInt);
            Optional<Coupon> coupon = couponRepository.findById(iInteger);
            // 쿠폰 상태가 true 값으로 잘 있다면 진입
            if(coupon.get().isStatus()){
                if(!coupon.get().isUsingOne()){
                    log.info("쿠폰 단독 사용 불가");
                    return "단독으로 사용 불가한 쿠폰 입니다.";
                }

                // 날짜 잡아주기
                Date datetime2 = new Date();
                SimpleDateFormat simpleDateFormat = new SimpleDateFormat("MM월 dd일 HH시 mm분", Locale.KOREA);
                SimpleDateFormat simpleDateFormat1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.KOREA);
                String createdDate1 = simpleDateFormat.format(datetime2);
                String createdDate2 = simpleDateFormat1.format(datetime2);

                KakaoPayPayment kakaoPayPayment = new KakaoPayPayment();
//                Date datetime = new Date();
//                SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.KOREA);
//                String createdDate = simpleDateFormat2.format(datetime);
//                Date datetime3 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(createdDate);
                //kakaoPayPayment.setCreated_at(simpleDateFormat1.parse(createdDate2));
                kakaoPayPayment.setCreated_at(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.KOREA).parse(createdDate2));
                kakaoPayPayment.setApproved_at(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.KOREA).parse(createdDate2));
                log.info(simpleDateFormat1.toString());
                log.info("데이트 출력 : " + createdDate2);


                // 결제되면 푸시 보냄
                log.info("사용자한테 보낸 푸시");
                String notifications = PushPeriodicNotifications.SuccessOrder(kakaopay.getPartner_user_id(), "Thank you!", "Please wait 5 miniute", users.getFirebaseToken());
                log.info(notifications);
                HttpEntity<String> request = new HttpEntity<>(notifications);

                CompletableFuture<String> pushNotification = pushNotificationService.send(request);
                CompletableFuture.allOf(pushNotification).join();


                Iterable<Users> users3 = usersRepository.findAll();
                Iterator<Users> usersIterator = users3.iterator();
                Iterator<Users> usersIterator1 = users3.iterator();
                int j = 0; // 현재 유저의 수
                while(usersIterator.hasNext()){
                    usersIterator.next();
                    j++;
                }



                // 유저 수 만큼 반복
                for(int i = 0; i< j; i++){
                    Users users4 = usersIterator1.next();
                    // 유저의 권한이 6이상이면
                    if(users4.getUserPermission() >= 6){
                        log.info("권한이 있음 6 이상이야!");
                        String notifications1 = PushPeriodicNotifications.SuccessOrder(users4.getUserName(), "Order!", "Please confirm in app", users4.getFirebaseToken());
                        log.info(notifications1);
                        HttpEntity<String> request1 = new HttpEntity<>(notifications1);

                        CompletableFuture<String> pushNotification1 = pushNotificationService2.send(request1);
                        CompletableFuture.allOf(pushNotification1).join();
                    }
                }





                // 요일 설정
                Calendar cal = Calendar.getInstance();
                //현재 일자의 요일
                String dTime = simpleDateFormat.format(datetime2);
                cal.setTime(simpleDateFormat.parse(dTime));
                int dayNum = cal.get(Calendar.DAY_OF_WEEK);

                String day = "";
                switch(dayNum){
                    case 1:
                        day = "금";
                        break ;
                    case 2:
                        day = "토";
                        break ;
                    case 3:
                        day = "일";
                        break ;
                    case 4:
                        day = "월";
                        break ;
                    case 5:
                        day = "화";
                        break ;
                    case 6:
                        day = "수";
                        break ;
                    case 7:
                        day = "목";
                        break ;
                }

                // 오더리스트에 저장도 해줘야지..?
                OrderList orderList = new OrderList();
                orderList.setOrderMesage(createdDate1+ " " + day + "요일" + " - " + coupon.get().getCouponName() + " - " + "쿠폰 번호 : " + coupon.get().getId() + " - " + coupon.get().getUserName());
                orderList.setState(true);
                orderListRepository.save(orderList);

                // 쿠폰 비활성화
                coupon.get().setStatus(false);
                couponRepository.save(coupon.get());

                kakaoPayPayment.setItem_name(orderList.getOrderMesage());
                kakaoPayPayment.setMoney(coupon.get().getCost());
                kakaoPayPayment.setPartner_user_id(coupon.get().getUserName());
                kakaoPayPaymentRepository.save(kakaoPayPayment);
                // true 리턴해주면 앱에서는 한번 더 getCoupon 해야함
                return "true";
            }
        }
        else {
            return "내부적 오류가 발생하였습니다.";
        }



        return "인증에 실패했습니다. 재로그인 해주세요.";
    }


    @Setter(onMethod_ = @Autowired)
    private KakaoPay kakaopay;

    @PostMapping("/kakaoPay2")
    public KakaoPayReadyVO kakaoPay2(@RequestBody FlutterOrder flutterOrder) {
        log.info("플루터 kakaoPay2 post............................................");
        //log.info(model.toString());
        // 쿠폰 스플릿 해주기
        String coupon[] = flutterOrder.getItem_name().split("쿠폰 번호 : ");
        log.info(coupon[0]);
        if(coupon.length >= 2){
            log.info("쿠폰 검증중");
            String coupon2[] = coupon[1].split("  쿠폰 이름");
            Integer iInteger = Integer.parseInt(coupon2[0]);
            Optional<Coupon> userCoupon = couponRepository.findById(iInteger);
            if(!userCoupon.get().isStatus()){
                return null;
            }
        }
        //model.addAttribute("info");
        log.info("@@@@@@@@@@");
        log.info("@@@@@@@@@@");
        log.info(flutterOrder.getItem_name());
        log.info(flutterOrder.getTotal_amount());
        return kakaopay.flutterkakaoPayReady(flutterOrder);

    }

    // 쇼핑 카트 컨트롤
    @RequestMapping(value = "/setShopping", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public /*@ResponseBody
    Shopping*/ Shopping Shopping(
            //@RequestBody Shopping shopping
            @RequestBody FlutterShopping flutterShopping) {
        log.info("플루터 쇼핑카트 넣어버리기");
        // 장바구니가 이미 생성되어있다면 && 세션이 갖고 있는 이름과 장바구니 소유자의 이름이 같아야지만 값을 넣어줌
        if (shoppingRepository.findByUserName(flutterShopping.getUserName()) != null) {
            // 기존의 장바구니 정보를 받아옴 + 추가되는 주문들 넣어줌
            log.info("완전한 데이터");
            Shopping shopping = shoppingRepository.findByUserName(flutterShopping.getUserName());
            // 저장
            shopping.setList(shopping.getList() + flutterShopping.getList() + ",");
            shopping.setNum(shopping.getNum() + flutterShopping.getNum() + ",");
            shopping.setSum_cost(shopping.getSum_cost() + flutterShopping.getSum_cost() + ",");
            // 다시 저장
            shoppingRepository.save(shopping);
            return shopping;
        }

        // 장바구니가 비어있는 상태라면
        else {
            log.info("장바구니 비어있는지 검증");
            // 안비어있음
            if (shoppingRepository.findByUserName(flutterShopping.getUserName()) != null) {
                log.info("안비어있음");
                Shopping shopping = shoppingRepository.findByUserName(flutterShopping.getUserName());
                shopping.setList(shopping.getList() + flutterShopping.getList() + ",");
                shopping.setNum(shopping.getNum() + flutterShopping.getNum());
                shopping.setSum_cost(shopping.getSum_cost() + flutterShopping.getSum_cost());
                shoppingRepository.save(shopping);

                return shopping;
            }
            log.info("비어있음");
            Shopping shopping = new Shopping(flutterShopping.getUserName(), flutterShopping.getList(), flutterShopping.getNum(), flutterShopping.getSum_cost());
            shopping.setList(flutterShopping.getList() + ", ");
            shoppingRepository.save(shopping);
            return shopping;
        }
    }

    @RequestMapping(value = "/getShopping", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public /*@ResponseBody
    Shopping*/ Shopping getShopping(
            //@RequestBody Shopping shopping
            @RequestBody FlutterShopping flutterShopping) {
        log.info("플루터 쇼핑카트 넣어버리기");
        // 장바구니가 이미 생성되어있다면 && 세션이 갖고 있는 이름과 장바구니 소유자의 이름이 같아야지만 값을 넣어줌
        if (shoppingRepository.findByUserName(flutterShopping.getUserName()) != null) {
            // 기존의 장바구니 정보를 받아옴 + 추가되는 주문들 넣어줌
            log.info("완전한 데이터");
            Shopping shopping = shoppingRepository.findByUserName(flutterShopping.getUserName());
            shoppingRepository.save(shopping);
            return shopping;
        }

        // 장바구니가 비어있는 상태라면
        else {
            return null;
        }
    }

    // 쇼핑 카트 컨트롤
    @RequestMapping(value = "/saveShopping", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public /*@ResponseBody
    Shopping*/ Shopping saveShopping(
            //@RequestBody Shopping shopping
            @RequestBody FlutterShopping flutterShopping) {
        log.info("플루터 쇼핑카트 저장하기");
        // 장바구니가 이미 생성되어있다면 && 세션이 갖고 있는 이름과 장바구니 소유자의 이름이 같아야지만 값을 넣어줌
        if (shoppingRepository.findByUserName(flutterShopping.getUserName()) != null) {
            // 기존의 장바구니 정보를 받아옴 + 추가되는 주문들 넣어줌
            log.info("완전한 데이터");
            Shopping shopping = shoppingRepository.findByUserName(flutterShopping.getUserName());
            // 저장
            shopping.setList(flutterShopping.getList());
            shopping.setNum(flutterShopping.getNum());
            shopping.setSum_cost(flutterShopping.getSum_cost());
            // 다시 저장
            shoppingRepository.save(shopping);
            return shopping;
        }

        // 장바구니가 비어있는 상태라면
        else {
            log.info("장바구니 비어있는지 검증");
            // 안비어있음

            return null;
        }
    }


    // 장바구니 비우기
    @PostMapping("removeShopping")
    public Shopping removeShopping(@RequestBody FlutterShopping flutterShopping) {
        log.info("플루터 장바구니 비우기");
        log.info(flutterShopping.getUserName());
        // 당연히 값 있어야함
        if (shoppingRepository.findByUserName(flutterShopping.getUserName()) != null) {
            Shopping shopping = shoppingRepository.findByUserName(flutterShopping.getUserName());
            shopping.setList("");
            shopping.setNum("");
            shopping.setSum_cost("");
            shoppingRepository.save(shopping);

            log.info("장바구니 비우기 성공");
            return shopping;
        }
        return null;
    }

    // 구매 내역 결제내역 뽑아서 줌
    @RequestMapping(value = "getMyPayment", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    KakaoPayPayment[] getMyPayment(
            @RequestBody Login login) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException {
        // 암호화하여 처리
        login.setId(AES256Cipher.AES_Encode(login.getId()));
        login.setPassword(AES256Cipher.AES_Encode(login.getPassword()));

        Users users = usersRepository.findByUserLoginIdAndUserLoginPassword(login.getId(), login.getPassword());
        if (users != null) {

            Iterable<KakaoPayPayment> kakaoPayPayment = kakaoPayPaymentRepository.findAllDesc();
            Iterator<KakaoPayPayment> kpp = kakaoPayPayment.iterator(); // 마스터 계정에 쓰이는 변수
            Iterator<KakaoPayPayment> kpp2 = kakaoPayPayment.iterator(); // 전체 길이를 담아주는 변수
            Iterator<KakaoPayPayment> kpp3 = kakaoPayPayment.iterator(); // 전체 길이를 담아주는 변수

            int j = 0;
            while(kpp2.hasNext()){
                kpp2.next();
                j++;
            }

            // 마스터에게는 주문했던 개수만큼 보여줄 것임
            KakaoPayPayment kakaoPayPaymentArray[] = new KakaoPayPayment[j];
            //log.info("j의 길이는 " + j);
            // 마스터 계정일 경우 결제내역의 개수만큼 배열에 담아서 리턴
            // 아닐경우는 유저것만 담아서 리턴
            int i = 0;
            // master 계정일 경우
            if (users.getUserName().equals("master")) {
                log.info("마스터 계정임");
                while (kpp.hasNext()) {
                    KakaoPayPayment ka = kpp.next();
                    kakaoPayPaymentArray[i] = ka;
                    i++;
                }
                // return null;
                // 굳이 마스터는 반환안해도 될듯
                return kakaoPayPaymentArray;
            }

            // devHi 계정일 경우
//            if (users.getUserName().equals("devHi")) {
//                log.info("개발자 계정임");
//                while (kpp.hasNext()) {
//                    KakaoPayPayment ka = kpp.next();
//                    kakaoPayPaymentArray[i] = ka;
//                    i++;
//                }
//                // return null;
//                // 굳이 마스터는 반환안해도 될듯
//                return kakaoPayPaymentArray;
//            }

            if(users.getUserPermission() >= 6){
                log.info("권한이 6 이상인 사람임");
                while (kpp.hasNext()) {
                    KakaoPayPayment ka = kpp.next();
                    kakaoPayPaymentArray[i] = ka;
                    i++;
                }
                // return null;
                // 굳이 마스터는 반환안해도 될듯
                return kakaoPayPaymentArray;
            }

            while (kpp.hasNext()) {
                KakaoPayPayment ka = kpp.next();
                // log.info(users.getUserName() + " - " + ka.getPartner_user_id());
                // 같다면
                if (ka.getPartner_user_id().equals(users.getUserName())) {
                    // log.info(i + " 같다! " + ka.getNum());
                    kakaoPayPaymentArray[i] = ka;
                    i++;
                }
            }



            KakaoPayPayment kakaoPayPaymentArray2[] = new KakaoPayPayment[i];

            for(int j2 = 0 ; j2 < i; j2++){
                kakaoPayPaymentArray2[j2] = kakaoPayPaymentArray[j2];
            }
            // 이 배열의 크기가 1보다 커야 반환
            if (kakaoPayPaymentArray2.length >= 1) {
                log.info("왜 Null값까지?");

//                log.info("길이 : " + kakaoPayPaymentArray2.length);
//                for(int ij = 0; ij< kakaoPayPaymentArray2.length; ij++){
//                    log.info(kakaoPayPaymentArray2[ij].getPartner_user_id());
//                }
                return kakaoPayPaymentArray2;

            }
        }


        return null;
    }


    // 마스터 계정일 때
    @RequestMapping(value = "getOrderList", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    OrderList[] getOrderList(
            @RequestBody Login login) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException {

        // 암호화하여 처리
        login.setId(AES256Cipher.AES_Encode(login.getId()));
        login.setPassword(AES256Cipher.AES_Encode(login.getPassword()));

        Users users = usersRepository.findByUserLoginIdAndUserLoginPassword(login.getId(), login.getPassword());
        if (users != null){
            Iterable<OrderList> orderList = orderListRepository.findAllDesc();
            Iterator<OrderList> orderListIterator = orderList.iterator();
            Iterator<OrderList> orderListIterator2 = orderList.iterator();

            int j = 0;
            while (orderListIterator2.hasNext()){
                orderListIterator2.next();
                j++;
            }

            // 최근 개수만큼만 보여줄 것임
            OrderList orderLists[] = new OrderList[j];
            int i = 0;
            // master 계정일 경우
            if (users.getUserName().equals("master") || users.getUserPermission() >= 6) {
                while (orderListIterator.hasNext()) {
                    OrderList or = orderListIterator.next();
                    // 주문상태가 트루인것만 담아서 보내줄 예정
                    if (or.isState()){
                        orderLists[i] = or;
                        i++;
                    }
                }
                if(orderLists[0] == null){
                    log.info("오더리스츠[0] 값 널임");
                    return null;
                }
                return orderLists;
            }


        }

        return null;

    }

    // deleteOrderList
    @RequestMapping(value = "deleteOrderList", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    String deleteOrderList(
            @RequestBody Login login) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException {
        login.setId(AES256Cipher.AES_Encode(login.getId()));
        login.setPassword(AES256Cipher.AES_Encode(login.getPassword()));
        log.info("delete 들어옴");
        Users users = usersRepository.findByUserLoginIdAndUserLoginPassword(login.getId(), login.getPassword());

        if (users != null) {
            OrderList orderList = orderListRepository.getOne(Integer.parseInt(login.getFirebaseToken()));
            log.info("과연" + orderList.getOrderMesage());
            orderList.setState(false);
            orderListRepository.save(orderList);

            return "success";
        }
        return "fail";
    }


    // 이메일 인증 코드 보내는 코드
    @RequestMapping(value = "emailAuth", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody

    String emailAuth(
            @RequestBody SignUp signUp) {

        Users users = usersRepository.findByUserEmail(signUp.getEmail());
        if(users != null){
            return "이미 가입되어 있는 이메일 입니다.";
        }

        // 랜덤한 8자리 코드 발송
        String uuid = UUID.randomUUID().toString();
        uuid = uuid.substring(0,4);

        // 날짜 생성
        Date date = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMddHHmmss");
        String createdDate1 = simpleDateFormat.format(date);
        String untilDate1 = simpleDateFormat.format(date);
        long createdDate = Long.parseLong(createdDate1);
        long untilDate = Long.parseLong(untilDate1) + 60 * 5; // 5분안에 해야함

        // 이메일 객체 담기
        SignupEmailAuth signupEmailAuth = new SignupEmailAuth(true, uuid, createdDate, untilDate, signUp.getEmail());
        signupEmailAuthRepository.save(signupEmailAuth);
        EmailServiceImpl es = new EmailServiceImpl();
        es.setJavaMailSender(javaMailSender);
        log.info("---이메일 전송함---");
        log.info("이메일: " + signUp.getEmail() + " 인증코드: " + uuid);
        es.sendSimpleMessage(signUp.getEmail(),"카페코스테스 회원가입 인증 코드입니다.", "아래의 코드 4자리를" +
                "붙여넣어주세요.\n" +
                uuid + "\n" +
                "문의사항이 있으시면 kbi960130@bible.ac.kr로 문의주세요");

        return "true";
    }


    // 코드 입력해서 넘어가는 곳
    @RequestMapping(value = "signupEmailAuth", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody String signupEmailAuth(@RequestBody SignUp signUp){
        // 유효하다면
        // 코드 받는거임 이메일 아님
        if(signupEmailAuthRepository.findByCode(signUp.getEmail()) != null){
            SignupEmailAuth signupEmailAuth = signupEmailAuthRepository.findByCode(signUp.getEmail());

            // 날짜 생성
            Date date = new Date();
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMddHHmmss");
            String createdDate1 = simpleDateFormat.format(date);
            long createdDate = Long.parseLong(createdDate1);
            log.info(createdDate + "");
            log.info(signupEmailAuth.getUntilDate() + "");
            if ( createdDate > signupEmailAuth.getUntilDate()){
                log.info("인증 시간 초과");
                return "인증 시간이 초과 되었습니다.";
            }
            if (!signupEmailAuth.isStatus()){
                log.info("이미 사용된 코드");
                return "이미 사용된 코드 입니다.";
            }



            signupEmailAuth.setStatus(false);

            signupEmailAuthRepository.save(signupEmailAuth);
            log.info(signupEmailAuth.getEmail());
            return signupEmailAuth.getEmail();
        }
        else {
            return "fail";
        }


    }
    @RequestMapping(value = "signup", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    // true 일때만 가입되게 해야함 id pw pw2 nick 다 받아서 클라에서도 검증하고 서버에서 검증하자
    String signup(
            @RequestBody SignUp signUp) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException {

        // 입력하지 않을경우
        if(signUp.getId().equals("") || signUp.getPassword().equals("") || signUp.getPassword2().equals("") || signUp.getNickname().equals("") || signUp.getEmail().equals("") ){
            return "입력하지 않은 칸이 있습니다.";
        }
        // 로그인 아이디 영어 소대문자 숫자만 받자
        char chrInput2;
        for (int i = 0 ; i < signUp.getId().length(); i++){
            chrInput2 = signUp.getId().charAt(i);
            if (chrInput2 >= 0x61 && chrInput2 <= 0x7A) {
                // 영문(소문자) OK!
            }
            else if (chrInput2 >=0x41 && chrInput2 <= 0x5A) {
                // 영문(대문자) OK!
            }
            else if (chrInput2 >= 0x30 && chrInput2 <= 0x39) {
                // 숫자 OK!
            }
            else {
                // 영문자도 아니고 숫자도 아님!
                return "로그인 아이디는 영어 소대문자 및 숫자만 입력해주세요.";
            }
        }


        // 암호화하여 처리
        signUp.setId(AES256Cipher.AES_Encode(signUp.getId()));
        signUp.setPassword(AES256Cipher.AES_Encode(signUp.getPassword()));
        signUp.setPassword2(AES256Cipher.AES_Encode(signUp.getPassword2()));

        Users users = usersRepository.findByUserLoginId(signUp.getId());



        // 생년월일
        char birthInput;
        if(signUp.getBirthday().length() != 6){
            return "생년월일 6자를 입력해주세요";
        }
        for (int i = 0 ; i < signUp.getBirthday().length(); i++){
            birthInput = signUp.getBirthday().charAt(i);
            if (birthInput >= 0x30 && birthInput <= 0x39) {
                // 숫자 OK!
            }
            else {
                // 숫자가 아님
                return "숫자만 입력해주세요.";
            }
        }

        // users가 빈값이어야 함 있으면 아이디가 있습니다 반환
        if (users != null){
            return "이미 존재하는 아이디 입니다.";
        }
        // 비밀번호가 다르다면!
        if (!signUp.getPassword().equals(signUp.getPassword2())){
            return "비밀번호가 같지 않습니다. ";
        }

        // 닉네임도 소대문자와 숫자만
        char chrInput;
        for (int i = 0 ; i < signUp.getNickname().length(); i++){
            chrInput = signUp.getNickname().charAt(i);
            if (chrInput >= 0x61 && chrInput <= 0x7A) {
                // 영문(소문자) OK!
            }
            else if (chrInput >=0x41 && chrInput <= 0x5A) {
                // 영문(대문자) OK!
            }
            else if (chrInput >= 0x30 && chrInput <= 0x39) {

                // 숫자 OK!
            }
            else {
                // 영문자도 아니고 숫자도 아님!
                return "닉네임은 영어 및 숫자만 입력해주세요.(카카오페이 결제시 에러가 나요 ㅠㅠ)";
            }
        }

        Users users2 = usersRepository.findByUserName(signUp.getNickname());
        if (users2 != null){
            return "이미 존재하는 닉네임 입니다.";
        }

        Users users3 = usersRepository.findByUserEmail(signUp.getEmail());
        if (users3 != null){
            return "이미 존재하는 이메일 입니다.";
        }

        Date datetime2 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy년 MM월 dd일 HH시 mm분");
        String createdDate1 = simpleDateFormat.format(datetime2);

        Users users1 = new Users(signUp.getId(), signUp.getPassword(), signUp.getNickname(), 0, createdDate1, signUp.getEmail(), signUp.getBirthday());

        usersRepository.save(users1);

        // 회원가입 했을 때 이벤트 처리   쿠폰 이름 , 발급자 , 유저 이름  -  아메리카노 한잔 지냐후
        Coupon coupon = new Coupon("무료 사이즈 업", createdDate1 , "사장님", signUp.getNickname(), 500);
        couponRepository.save(coupon);
        return "회원가입이 완료되었습니다. 로그인 해주세요!";
    }

    // 이메일 이용하여 로그인 아이디 찾기
    @RequestMapping(value = "findID", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
        // true 일때만 가입되게 해야함 id pw pw2 nick 다 받아서 클라에서도 검증하고 서버에서 검증하자
    String findID(@RequestBody SignUp signUp) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException {
        // 이메일로 찾음
        Users users = usersRepository.findByUserEmail(signUp.getEmail());
        if (users != null){
            // 이메일 객체 담기
            EmailServiceImpl es = new EmailServiceImpl();
            es.setJavaMailSender(javaMailSender);
            log.info("---플루터 아이디찾기 이메일 전송함---");
            users.setUserLoginId(AES256Cipher.AES_Decode(users.getUserLoginId()));

            log.info("이메일: "+ users.getUserEmail() + " 유저 로그인 아이디: " + users.getUserLoginId());
            es.sendSimpleMessage(users.getUserEmail(),users.getUserName() + "님 로그인 아이디 입니다.", users.getUserName() + " 님의 로그인 아이디는 : " +
                    users.getUserLoginId() + " 입니다.\n" +
                    "문의사항이 있으시면 kbi960130@bible.ac.kr로 문의주세요");
            return "이메일로 아이디를 보내드렸습니다.";
        }
        else {
            return "해당 이메일에 맞는 계정이 존재하지 않습니다.";
        }
    }

    //
    @RequestMapping(value = "findPassword", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
        // true 일때만 가입되게 해야함 id pw pw2 nick 다 받아서 클라에서도 검증하고 서버에서 검증하자
    String findPassword(@RequestBody SignUp signUp) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException {
        signUp.setId(AES256Cipher.AES_Encode(signUp.getId()));
        Users users = usersRepository.findByUserLoginIdAndUserEmail(signUp.getId(), signUp.getEmail());
        if (users != null){
            // 임시 비밀번호 생성
            String uuid = UUID.randomUUID().toString();
            uuid = uuid.substring(0,8);

            // 이메일 객체 담기
            EmailServiceImpl es = new EmailServiceImpl();
            es.setJavaMailSender(javaMailSender);
            log.info("---플루터 비밀번호 찾기 이메일 전송함---");
            log.info("이메일: "+ users.getUserEmail() + " 유저 임시 비밀번호: " + uuid);
            es.sendSimpleMessage(users.getUserEmail(),users.getUserName() + "님 임시 비밀번호 입니다.", users.getUserName() + " 님의 임시 비밀번호는 : " +
                    uuid + " 입니다.\n" +
                    "앱에서 로그인 하신 후 마이페이지에서 변경해주시기 바랍니다." +
                    "문의사항이 있으시면 kbi960130@bible.ac.kr로 문의주세요");

            // uuid를 암호화해서 저장
            uuid = AES256Cipher.AES_Encode(uuid);
            users.setUserLoginPassword(uuid);
            usersRepository.save(users);
            return "이메일로 임시 비밀번호를 설정하여 보내드렸습니다.";
        }
        else {
            return "해당 아이디와 이메일에 맞는 계정이 존재하지 않습니다.";
        }
    }

    // 닉네임 변경
    @RequestMapping(value = "changeName", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
        // true 일때만 가입되게 해야함 id pw pw2 nick 다 받아서 클라에서도 검증하고 서버에서 검증하자
    String changeName(@RequestBody SignUp signUp) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException {

        // 암호화하여 처리
        signUp.setId(AES256Cipher.AES_Encode(signUp.getId()));
        signUp.setPassword(AES256Cipher.AES_Encode(signUp.getPassword()));

        // 로그인 먼저 해보고!

        Users users = usersRepository.findByUserLoginIdAndUserLoginPassword(signUp.getId(), signUp.getPassword());
        if (users == null){
            return "아이디나 비밀번호가 틀렸습니다.";
        }

        // 닉네임도 소대문자와 숫자만
        char chrInput;
        for (int i = 0 ; i < signUp.getNickname().length(); i++){
            chrInput = signUp.getNickname().charAt(i);
            if (chrInput >= 0x61 && chrInput <= 0x7A) {
                // 영문(소문자) OK!
            }
            else if (chrInput >=0x41 && chrInput <= 0x5A) {
                // 영문(대문자) OK!
            }
            else if (chrInput >= 0x30 && chrInput <= 0x39) {
                // 숫자 OK!
            }
            else {
                // 영문자도 아니고 숫자도 아님!
                return "닉네임은 영어 및 숫자만 입력해주세요.(카카오페이 결제시 에러가 나요 ㅠㅠ)";
            }
        }

        Users users2 = usersRepository.findByUserName(signUp.getNickname());
        if (users2 != null){
            return "이미 존재하는 닉네임 입니다.";
        }

        users.setUserName(signUp.getNickname());
        usersRepository.save(users);
        return "성공적으로 변경 되었습니다.";
    }

    // 비밀번호 변경
    @RequestMapping(value = "changePassword", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    // true 일때만 가입되게 해야함 id pw pw2 nick 다 받아서 클라에서도 검증하고 서버에서 검증하자
    String changePassword(@RequestBody SignUp signUp) throws NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, InvalidKeyException {

        // 암호화하여 처리
        signUp.setId(AES256Cipher.AES_Encode(signUp.getId()));
        signUp.setEmail(AES256Cipher.AES_Encode(signUp.getEmail()));

        // 로그인 먼저 해보고! 여기서는 이메일이 비밀번호임
        Users users = usersRepository.findByUserLoginIdAndUserLoginPassword(signUp.getId(), signUp.getEmail());
        if (users == null){
            return "아이디나 비밀번호가 틀렸습니다.";
        }

        if(!signUp.getPassword().equals(signUp.getPassword2())){
            return "새로 설정하는 비밀번호가 같지 않습니다.";
        }
        signUp.setPassword(AES256Cipher.AES_Encode(signUp.getPassword()));
        users.setUserLoginPassword(signUp.getPassword());
        usersRepository.save(users);
        return "성공적으로 변경 되었습니다.";
    }


    @RequestMapping(value = "getListMenuLength", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody String getListMenuLength(){
        Iterable<Menu> menu = menuRepository.findAll();
        Iterator<Menu> menu2 = menu.iterator();

        int i = 0;

        int j1 = 0;
        int j2 = 0;
        int j3 = 0;
        int j4 = 0;
        int j5 = 0;
        int j6 = 0;

        while(menu2.hasNext()){
            Menu menu1 = menu2.next();
            if(menu1.getCategory().equals("NEW")){
                log.info("NEW");
                j1++;
            }
            else if(menu1.getCategory().equals("에스프레소")){
                log.info("에스프레소");
                j2++;
            }
            else if(menu1.getCategory().equals("라떼")){
                log.info("라떼");
                j3++;
            }
            else if(menu1.getCategory().equals("에이드/스무디")){
                log.info("에이드/스무디");
                j4++;
            }
            else if(menu1.getCategory().equals("티")){
                log.info("티");
                j5++;
            }
            else if(menu1.getCategory().equals("콜드 브루")){
                log.info("콜드 브루");
                j6++;
            }
            i++;
        }

        log.info("메뉴 길이" + i);
        String h = j1 + "," + j2 + "," +  j3 + "," +  j4 + "," +  j5 + "," + j6;
        return h;
    }


    @RequestMapping(value = "getListEss", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody String getListEss() {
        Iterable<Menu> menu = menuRepository.findAll();
        Iterator<Menu> menu2 = menu.iterator();

        ArrayList<String> ess = new ArrayList<String>();

        while(menu2.hasNext()) {
            Menu menu1 = menu2.next();
            if(menu1.getCategory().equals("NEW")){
                ess.add(menu1.getMenuName());
            }
        }
        log.info(ess.toString());

        String hi;
        hi = ess.toString().replace("[", "");
        hi = hi.replace("]", "");
        hi = hi.replace(" ", "");
        log.info(hi);
        return hi;
    }

    @RequestMapping(value = "getListAde", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody String getListAde() {
        Iterable<Menu> menu = menuRepository.findAll();
        Iterator<Menu> menu2 = menu.iterator();

        ArrayList<String> ess = new ArrayList<String>();

        while(menu2.hasNext()) {
            Menu menu1 = menu2.next();
            if(menu1.getCategory().equals("에스프레소")){
                ess.add(menu1.getMenuName());
            }
        }
        log.info(ess.toString());

        String hi;
        hi = ess.toString().replace("[", "");
        hi = hi.replace("]", "");
        hi = hi.replace(" ", "");
        log.info(hi);
        return hi;
    }

    @RequestMapping(value = "getListLatte", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody String getListLatte() {
        Iterable<Menu> menu = menuRepository.findAll();
        Iterator<Menu> menu2 = menu.iterator();

        ArrayList<String> ess = new ArrayList<String>();

        while(menu2.hasNext()) {
            Menu menu1 = menu2.next();
            if(menu1.getCategory().equals("라떼")){
                ess.add(menu1.getMenuName());
            }
        }
        log.info(ess.toString());

        String hi;
        hi = ess.toString().replace("[", "");
        hi = hi.replace("]", "");
        hi = hi.replace(" ", "");
        log.info(hi);
        return hi;
    }

    @RequestMapping(value = "getListHub", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody String getListHub() {
        Iterable<Menu> menu = menuRepository.findAll();
        Iterator<Menu> menu2 = menu.iterator();

        ArrayList<String> ess = new ArrayList<String>();

        while(menu2.hasNext()) {
            Menu menu1 = menu2.next();
            if(menu1.getCategory().equals("에이드/스무디")){
                ess.add(menu1.getMenuName());
            }
        }
        log.info(ess.toString());

        String hi;
        hi = ess.toString().replace("[", "");
        hi = hi.replace("]", "");
        hi = hi.replace(" ", "");
        log.info(hi);
        return hi;
    }

    @RequestMapping(value = "getListShake", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody String getListShake() {
        Iterable<Menu> menu = menuRepository.findAll();
        Iterator<Menu> menu2 = menu.iterator();

        ArrayList<String> ess = new ArrayList<String>();

        while(menu2.hasNext()) {
            Menu menu1 = menu2.next();
            if(menu1.getCategory().equals("티")){
                ess.add(menu1.getMenuName());
            }
        }
        log.info(ess.toString());

        String hi;
        hi = ess.toString().replace("[", "");
        hi = hi.replace("]", "");
        hi = hi.replace(" ", "");
        log.info(hi);
        return hi;
    }

    @RequestMapping(value = "getListSummer", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody String getListSummer() {
        Iterable<Menu> menu = menuRepository.findAll();
        Iterator<Menu> menu2 = menu.iterator();

        ArrayList<String> ess = new ArrayList<String>();

        while(menu2.hasNext()) {
            Menu menu1 = menu2.next();
            if(menu1.getCategory().equals("콜드 브루")){
                ess.add(menu1.getMenuName());
            }
        }
        log.info(ess.toString());

        String hi;
        hi = ess.toString().replace("[", "");
        hi = hi.replace("]", "");
        hi = hi.replace(" ", "");
        log.info(hi);
        return hi;
    }

    // serverStatus 카카오페이 결제할 때 쓰일 예정
    @RequestMapping(value = "serverStatus", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    String serverStatus(){
        //return "true";
        //return "카페 문이 닫혀있습니다.";
        ServerStatus serverStatus = serverStatusRepository.findByNumber(0);
        return serverStatus.getServerStatus();
    }

    // serverStatus 카카오페이 결제할 때 쓰일 예정
    @RequestMapping(value = "couponStatus", method = {RequestMethod.GET, RequestMethod.POST}, produces = "application/json")
    public @ResponseBody
    String couponStatus(){
        //return "true";
        //return "카페 문이 닫혀있습니다.";
        ServerStatus serverStatus = serverStatusRepository.findByNumber(1);
        return serverStatus.getServerStatus();
    }

}
